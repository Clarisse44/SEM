{\rtf1\ansi\ansicpg1252\cocoartf1265\cocoasubrtf210
{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww26100\viewh15820\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\pardirnatural

\f0\fs24 \cf0 config_data			Lists number of cells nc, number of elements ne, and number of pairs ne on separate lines. Subsequently repeats these numbers with text explanations, followed by the total time and centre of mass (presumably assuming one cell only?). Only the first 3 lines are read by the program. \
\
rng.f90				Random number generator\
\
ScEM_0_arrays.f90		Defines system arrays with allocatable dimensions. Real arrays 
\b potential_deriv
\b0 , 
\b x_cen
\b0  (specified 3D, not allocatable), 
\b xe_compare
\b0  and 
\b xe_prev
\b0 . Integer arrays 
\b head
\b0 , 
\b list
\b0  and 
\b pairs
\b0 . \
\
Scem_0_input.f90		Defines a large number of system parameters. 11/07/2013 - n_c_types and n_e_types both set to equal 2. Cell type 1 = epiblast. Cell type 2 = hypoblast. Element type 1 = cytoplasm. Element type 2 = cortex. 
\b rel_strength
\b0  array updated with values for interactions between all these possibilities, including a basic implementation of differential adhesion. Epiblast cortex-epiblast cortex set to have relative strength 0.75 while epiblast-hypoblast cortex and hypoblast-hypoblast cortex have 0.5.\
\
ScEM_0_ran_array.f90	Creates a random array "rap" with allocatable dimensions "brow" and "ncol" using rng.f90\
\
ScEM_0_useful.f90		Defines some commonly used loop variables e.g. i, j, k as global variables accessible by all functions. \
\
ScEM_1_inflexion.f90	Contains subroutine 
\b scem_inflexion
\b0  that uses the Newton-Raphson method to calculate the inflexion point in the potential between two elements. Writes inflexion point to a "potential_data" text file. I think the potential function must be repulsive at very short distances and attractive at larger distances, with only one inflexion point in between. Anything else would seem unphysical and the subroutine seems set up on the assumption that there is only one inflexion point. \
\
ScEM_1_potential.f90	Contains subroutine 
\b scem_potential
\b0 . Writes data to file potential_data (scale factor rho, potential minimum, epsilon, spring constant, force amplitude, time step dt, equilibrium point and maximum range). Also evaluates the potential function at different distances and writes results as a column of distances and corresponding column of potential values to the file potential_function. 
\b \

\b0 \
ScEM_1_types.f90		Defines "
\b element
\b0 " and "
\b cell
\b0 " data structures. Each structure, or "type" has several components. \
					Element contains integers 
\b label
\b0 , 
\b parent
\b0 , 
\b stage
\b0  and 
\b type
\b0 , reals 
\b age
\b0  and 
\b strength
\b0 , and 3D real arrays 
\b position
\b0  and 
\b velocity
\b0 . \
					Cell contains integer 
\b label
\b0 , reals 
\b age
\b0  and 
\b rad_gyration
\b0 , 3D real array 
\b position
\b0 , and integer array 
\b c_elements
\b0 . c_elements has 4*ne_cell components, plus a 0th component that gives the number of elements in the cell. The remaining components contain the numbers that label all elements in the cell. Every cell in the system is labelled with an integer, and if cell 2 contains elements 5, 9 and 17, then cells(2)%c_elements will contain values 5, 9 and 17. \
					Finally the subroutine creates an array of elements called 
\b elements
\b0  and an array of cells called 
\b cells
\b0 . These will contain the data for the system as it evolves in time. \
					12/06/13 - Module updated to include integer component "fate" in the cell type. "fate" labels the lineage of a particular cell, with fate=1 representing epiblast, fate=2 representing hypoblast, fate=3 representing trophoblast. Trophoblast may or may not be needed but no harm in including it for now. Note that in ScEM_0_input there is a variable n_c_types which is the number of cell types that is now changed to equal 3. \
\
ScEM_2_ageing.f90		Contains subroutine 
\b scem_ageing
\b0  that contains a do loop for all ne elements in which the 
\b age
\b0  component of each element data structure is incremented by 
\b dt
\b0 . Each element also has a component called the 
\b stage
\b0  that can take values 0, 1 or 2
\b . 
\b0 For each element, if stage=0 then the 
\b strength
\b0  component of the element is set to be the age of the element, divided by 
\b establishment_time
\b0 , squared, and if stage=0 and also age is greater than establishment time then stage is set to 1 and strength is set to 1.0. Finally, in a separate do loop for all nc cells, the 
\b age
\b0  component of each cell data structure is incremented by dt.\
\
ScEM_2_com.f90		Contains subroutine 
\b scem_com
\b0 . This subroutines uses a do loop over all nc cells to calculate the new position of the centre of max and the new radius of gyration for each cell after the positions of its constituent elements are updated by the master algorithm. These calculations are then used to update the 
\b position
\b0  and 
\b rad_gyration
\b0  components of the data structures for each cell. \
\
ScEM_2_deallocate.f90	Contains subroutine 
\b scem_deallocate
\b0  that deallocates data arrays 
\b elements
\b0 , 
\b cells
\b0 , 
\b potential_deriv
\b0 , 
\b xe_compare
\b0 , 
\b xe_prev
\b0 , 
\b head
\b0 , 
\b list
\b0 , 
\b pairs
\b0 , 
\b relative_strength
\b0 . This subroutine is called at the end of the master program to clean up used data structures so they can be reused without problems. \
\
ScEM_2_diffusion.f90	Contains subroutine 
\b scem_diffusion
\b0 . For every element this subroutine uses random number generator 
\b ran_array
\b0  to retrieve 4 random numbers and create 3 Gaussian random variates. These are then used to randomly shift the positions of all elements by small amounts to simulate stochastic processes in the system.\
\
ScEM_2_division.f90		After every iteration of the growth algorithm for the whole system, a loop is performed over all cells in the system to find those that contain a number of elements that is more than or equal to double ne_cell. For each cell that fulfils this criterion, an algorithm is performed that uses the maximum separation of cells in the system to work out the longest axis within the cell. When this longest axis is found, we can imagine a plane perpendicular to the axis that bisects it at the halfway point along its length. The cell is divided by taking all elements on one side of this plane, defining a new "cell" data structure, and allocating all elements on that side of the plane to the new "cell" data structure. All elements on the other side of the plane are left as constituents of the original cell. Since the elements in the new cell will interact with elements in the old cell with different potentials to when they were all part of the original cell, the system will relax to accommodate these new forces. Book keeping involves incrementing nc by 1.\
\
ScEM_2_flag_relist.f90	Contains subroutine 
\b scem_flag_relist
\b0  that tests the distance that every element has moved through in the previous iteration, and if any element has moved by a distance whose square is more than 0.25*buffer_size_sq then 
\b flag_relist
\b0  is set to 1, which will trigger reconstruction of the sector tables and pair array. \
\
ScEM_2_growth.f90		Module to incorporate cell growth into the program. Tim Newman comments that the algorithm may need to be improved and suggests talking to Mikael Bjorklund (Dundee, Cell and Developmental Biology, specialising in control of cell growth) about how to improve it. Module involves a subroutine which calls a random number, and if this random number is less than "prob_new_element" (from ScEM_0_input.f90), inserts a new element \
\
ScEM_2_identity.f90		Contains subroutine 
\b scem_identity
\b0 . Defines an array "counter(nc)" with a component corresponding to each of the nc cells. Then there is a do loop over all ne elements in which dummy variable k is set to equal "parent" component of element n. The kth element of "counter" is then incremented by 1. In this way, each element of "counter" is evaluated with the number of elements contained in the cell corresponding to that element of counter. So each time an element is examined and has "parent" value of, say, 2, the 2nd element of "counter" is incremented by 1. Subsequently the next element of the c_elements array within the kth cell data structure (i.e., the "counter(k) th" element in the array containing element directory information for all elements within the cell that contains the element under consideration) is evaluated to n, the numerical label of the element under consideration. This is repeated for all elements in the system. Finally, for all nc cells the 0th element of the c_elements array is evaluated using the corresponding final value of the counter array, so that c_elements(0) gives the number of elements in the cell, and all other components of c_elements contain the numerical labels of the elements contained within that cell. \
\
ScEM_2_initial_create.f90	Contains a subroutine 
\b scem_initial_create
\b0  that creates a cell and all of the elements within it. Creates elements at random positions within the cell volume, but excludes insertion of new elements too close to existing elements. Looks like it should write a ratio of number of elements created to number of attempts to create elements to somewhere, 
\b but as yet I am not sure where
\b0 . Uses elements(n)%position(:) = in a do loop over all n to update position component of all "element" structures in the elements array. \
\
ScEM_2_initial_exist.f90	Contains subroutine 
\b scem_initial_exist
\b0  that creates first cell by reading element positions from data file 
\b elements_config 
\b0 and initialising remaining "cell" data structure data.\
\
scem_4_integrate.f90	The SEM exhibits over-damped Langevin dynamics [32]. In order to update the system for every time step, a module exists that per- forms an integration method for all element pairs in the system (taken from the pairs array as described above) to solve the Langevin equation and calculate the instantaneous velocity for each element, given the potential interac- tions with its neighbours. These instantaneous velocities are then used to update the element positions by a 2nd order Runge-Kutta method. Contains a secondary section to include interactions with substrate if flag_substrate is equal to 1. 11/07/2013 - arguments of rel_strength used in integration algorithm changed to reflect possible variation in cell type. Substrate interaction section commented out for now. \
\
\
\
ScEM_2_output_final.f90	Writes positions of all elements to an output file "
\b element_final
\b0 ", and system data such as number of elements, number of cells, number of pairs and time to an output file "
\b end_of_run_data
\b0 ". First 3 numbers in "end_of_run_data" are ne, ne and np, and these are subsequently repeated with labels on the next 3 lines. There must be some reason why these values are quoted twice. 19/05/2013 - This subroutine edited to add element parent data to each line of elements_final data file. \
\
ScEM_2_output.f90		Prints element positions and the label of the cell from which each element comes to a file named "
\b elements
\b0 " for all elements in the system, followed by 2 blank lines. This is repeated after time steps of length 
\b time_out_1
\b0  so as to take snapshots of the system rather than print too much data. So "
\b elements
\b0 " contains a complete snapshot of the system at each sampling time step, with each time step separated by 2 blank lines. At the same time the subroutine prints: time, ne, nc, ne_size, nc_size, nx, ny, nz to the command line at intervals of 
\b time_out_2
\b0 . In the original code, time_out_2=10*time_out_1=cell_cycle_time/100. Finally for every time step of time_out_1, the subroutine creates or updates files for each cell. These files are called "fort.(30+k)" where k is the label for the cell. So for example the positions of all the elements in cell 1 are contained within file fort.31. These files are created or updated as necessary at every time step as the program runs. 25/05/13 - added a line to increment 
\b n_snapshots
\b0  with every call of scem_output, and print n_snapshots to the command line with the other data. This allows us to see how many times the system data is printed to the data file "elements". The subroutine now also creates a file called 
\b snapshot_data
\b0  that lists the number of cells in the system for every time step printed to "elements". This is needed for visualisation purposes. 20/06/13: Removed code that continually updates existing files for each cell, and added code that produces a data file for every cell, at every visualisation time step. These files are of the form fort.x where the first two digits of x give the time step number and the last two digits of x give the cell number. All of these data files are formatted for input into the voronoi program. \
\
\
ScEM_2_pairs.f90		The pairs array will contain all two-particle interactions - namely, all pairs of elements for which the inter-element distance is less that a certain value. That value is chosen to be slightly larger than the max range of the potential - this buffer allows one to use the same pairs array for many iterations before two elements which were not previously considered in the pairs array become within interaction range. Then a flag is triggered and the pairs array is reconstructed. There's an optimal balance in choosing the buffer - if it's too big, one is calculating a lot of unnecessary interations, if it's too small, the reconstruction is triggered too often. 10% beyond the max interaction range was optimal. Remember that the pairs array is set up to eliminate repetition. In other words, if interaction a-b is included, interaction b-a is not. Thus we do not need to worry about double counting. For the two elements in each component of the pairs array, the one with the lowest integer label is always the first, so pairs(m,1)<pairs(m,2). The purpose of scem_pairs is to update the number of pairs np after each iteration of the calculation, and to fill the pairs array with the new pairs data.\
					Important things to note in this module:\
					ixe(:) - A 3D array giving the position in space of an element in units of sector size. Evaluated afresh for every element n under consideration. Position is rounded to the nearest integer using int(\'85). Note this is rounded 					\ul down\ulnone . The rounding down is why adding 1 to each element makes for more meaningful sector assignment. ixe(:) then labels the 1st sector rather than the zeroth. \
					On arrays head(:,:,:) and list(:):\
					When scem_relist is called from scem_initialise, its argument is 0, which causes all components of head(:,:,:) to be evaluated to 0. Then all elements of list(:) are set to 0 because list(n)=head(ixe(1),ixe(2),ixe(3))=0. Then 					all elements of head(x,y,z) are set to equal the identifying label of the element within sector. If there is more than one element in a sector, the head value for that sector takes the highest value of the identifying labels in 					the sector. So if it contains elements 5, 17 and 39, head(x,y,z)=39.\
					Every time scem_relist is called thereafter, there is a component of list(n) for every element n in the system. For every element n the value of list(n) is set to be the head() value for the sector n is in. This means that 					list(n)=n \ul unless \ulnone there is another element in the same sector as n, in which case list(n)=m where m>n. If list(n) does not equal n then list(n) must be greater than n. head(x,y,z) is then updated according to the new 					positions of all elements. \
					Every time scem_relist is called thereafter, the argument given to it is 1, activating a loop over all elements n. In this loop, if list(n)=0, xe_compare(n,:), which contains the old positions of all elements, is used in ixe() to 					find the sector that the element used to be in. head(x,y,z) for that sector is then set to 0. \
\
ScEM_2_relist.f90		Updates sector array\
\
ScEM_2_resize.f90		When the number of elements in the system exceeds half of the dimension size of the elements array (ne_size) then system arrays are reallocated. Data is moved to a set of temporary arrays while system arrays are 					emptied, deallocated, and reallocated to be twice their previous size. Data is then moved back from the temporary arrays to the system arrays. Arrays involved are elements, xe_prev, xe_compare and list. \
					Then if the number of cells in the system exceeds half of the dimension size of the cells array (nc_size) then the cells array is also deallocated and resized to twice the previous size with data being stored in another 					temporary array. \
					Finally the maximum x, y and z positions of any cells are calculated in units of sector size and if any of these values exceeds one quarter of the number of sectors in that dimension (one quarter because it\'92s half of 					the number of sectors on either side of the centre of the sector grid\
\
\
ScEM_3_ initialize.f90	Contains subroutine scem_initialize that initialises 
\b time
\b0  to 0, then if 
\b flag_create
\b0 =1, it evaluates 
\b nc
\b0 , 
\b ne
\b0 , and 
\b np
\b0  according to values specified in code, otherwise it reads these data from a file called "
\b config_data
\b0 ". Allocates 
\b cells
\b0 , 
\b elements
\b0 ,
\b  xe_prev
\b0 ,
\b  xe_compare
\b0 ,
\b  head
\b0 ,
\b  list 
\b0 and 
\b pairs 
\b0 data array sizes. 
\b Need to look into these arrays in more detail. 
\b0 Subroutine then opens data files 
\b elements
\b0 , 
\b initialization_data, radius_gyration
\b0 , 
\b relist_log
\b0 , 
\b elements_new
\b0 . If variable 
\b flag_create
\b0  is equal to 1, subroutine calls another subroutine 
\b scem_initial_create
\b0 , or otherwise calls 
\b scem_initial_exist
\b0 . This ensures "elements" array contains up to date position information. The subroutine 
\b scem_relist
\b0  is then called with argument 0, followed by calling the subroutine 
\b scem_pairs
\b0 , then 
\b scem_identity
\b0 . Then system data is written to file 22, "
\b initialization_data
\b0 ": number of elements ne, number of pairs np etc. Finally the subroutine calls another subroutine, 
\b scem_output
\b0 . \
\
ScEM_3_iterate.f90		Contains subroutine 
\b scem_iterate
\b0  that comprises a large "while" loop such that 
\b while(time.lt.time_max)
\b0 , a procedure to update the system is performed. First, time is incremented by 
\b dt
\b0  (time=time+dt). Then the previous positions of all elements of the system are written to an array called 
\b xe_prev
\b0 . Subsequently calls 
\b scem_integrate
\b0  and increments system by half a step, updating position of all elements by 0.5*velocity*dt. Then sets all velocity components to 0 and repeats call of 
\b scem_integrate
\b0  and increments positions by a full time step. 
\b Need to clarify runge-kutta method and how half step then full step works. 
\b0 Then, 
\b if(flag_diffusion.eq.1)
\b0  the subroutine 
\b scem_diffusion
\b0  is called. 
\b flag_diffusion 
\b0 is defined in ScEM_0_input.f90 and is a variable that takes values of 1 or 0 to indicate whether diffusion is or is not being included in the system. flag_diffusion=1 implies it is includes, flag_diffusion=0 implies it is not. In the original code flag_diffusion was set to 0. Next, subroutine 
\b scem_flag_relist
\b0  is called and then if 
\b flag_relist
\b0 =1, 
\b scem_relist(1)
\b0  and 
\b scem_pairs
\b0  are called to reconstruct sector tables and pairs array. Contrast to scem_relist(0) called with argument of 0 in scem_initialize compared to argument of 1 here. After this the subroutine calls 
\b scem_aging
\b0 , then if 
\b flag_growth
\b0 =1, it calls 
\b scem_growth
\b0 , if 
\b flag_division
\b0 =1, it calls 
\b scem_division
\b0 , if 
\b flag_growth
\b0 =1 it calls 
\b scem_resize (does flag_growth change after calling scem_growth? Why is scem_resize not included in the previous if statement for flat_growth?)
\b0 . Finally calls 
\b scem_com
\b0  and 
\b scem_output
\b0  before closing data files. \
\
ScEM_master.f90		Sequentially calls subroutines 
\b scem_input
\b0 , 
\b scem_potential
\b0 , 
\b scem_inflexion
\b0 , 
\b scem_initialize
\b0 , 
\b scem_iterate
\b0 , 
\b scem_output_final
\b0 , 
\b scem_deallocate
\b0 .\
\
\
\
\
\
head(x,y,z) has a value for every sector (labelled by (x,y,z)) in the system. The value of head(x,y,z) is the label of the element in the sector with the largest label. So if a sector (a,b,c) contains elements 2, 17 and 35 then head(a,b,c)=35\
\
list(n) has a value for every element n. The value of list(n) is the highest integer label n_b in the same sector as n for which n_b<n If n is the lowest integer label of an elements in its sector then list(n)=0.\
\
Values for these two arrays are determined in scem_relist\
\
This set up of arrays allows scem_pairs to take a sector, then count down through the elements in that sector to determine if any of them are within range for interaction with the element being considered by scem_pairs. It does this by taking the head(x,y,z) value of the sector, checking the corresponding element and then passing the corresponding label n_a to list(:) to find the next element n_b=list(n_a). The loop stops when list(n)=0, which indicates that the last element in the sector has been reached. \
}